/* tslint:disable */
/* eslint-disable */
/**
 * T-Collab API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface Comment {
    'comment_id': string;
    'user_id': string;
    'suggestion_id': string;
    'comment_reply_to_id'?: string | null;
    'placed_at': string;
    'last_edit': string;
    'text': string;
}
export interface CommentIdReplyPostRequest {
    'text': string;
}
export interface CreateSuggestionRequest {
    'name': string;
    'description': string;
    'user_id': string;
}
export interface CurrentUser {
    'user_id': string;
    'email': string;
    'nickname': string;
    'avatar_url': string;
}
export interface Invite {
    /**
     * Идентификатор приглашения
     */
    'invite_id': string;
    /**
     * Идентификатор проекта
     */
    'project_id': string;
    /**
     * Email приглашённого пользователя
     */
    'email': string;
    /**
     * Дата и время отправки приглашения
     */
    'invited_at': string;
    'sender_nickname': string;
    'project_name': string;
    'receiver_nickname': string;
    'receiver_avatar'?: string;
}
export interface Like {
    'like_id'?: string;
    'user_id': string;
    'suggestion_id': string;
    'placed_at'?: string;
}
export interface ProjectBasic {
    'project_id': string;
    'name': string;
    'description': string;
}
export interface ProjectPermissions {
    'is_admin': boolean;
    'likes_remain': number;
}
export interface ProjectProjectIdSuggestionsGet200Response {
    'data'?: Array<Suggestion>;
}
export interface ProjectProjectIdSuggestionsPostRequest {
    'name': string;
    'description': string;
    'user_id': string;
    'status'?: ProjectProjectIdSuggestionsPostRequestStatusEnum;
}

export const ProjectProjectIdSuggestionsPostRequestStatusEnum = {
    Draft: 'draft',
    Discussion: 'discussion',
    Accepted: 'accepted',
    Rejected: 'rejected'
} as const;

export type ProjectProjectIdSuggestionsPostRequestStatusEnum = typeof ProjectProjectIdSuggestionsPostRequestStatusEnum[keyof typeof ProjectProjectIdSuggestionsPostRequestStatusEnum];

export interface ProjectSettings {
    'id': string;
    'name': string;
    'description': string;
    'vote_interval': string;
    'votes_for_interval': number;
    'owner_id': string;
}
export interface ProjectUser {
    'user_id': string;
    'email': string;
    'nickname': string;
    'is_admin': boolean;
    'avatar_url': string;
}
export interface ProjectUserList {
    /**
     * UUID проекта
     */
    'project_id': string;
    'users': Array<ProjectUser>;
}
export interface ProjectsGet200Response {
    'projects'?: Array<ProjectBasic>;
}
export interface ProjectsPost201Response {
    'project'?: ProjectBasic;
}
export interface ProjectsPostRequest {
    /**
     * project name
     */
    'name': string;
    /**
     * project description
     */
    'description': string;
}
export interface ProjectsProjectIdInvitesGet200Response {
    'data': Array<Invite>;
}
export interface ProjectsProjectIdSettingsGet200Response {
    'data'?: ProjectSettings;
}
export interface ProjectsProjectIdSettingsPutRequest {
    'name'?: string;
    'description'?: string;
    'vote_interval'?: string;
    'votes_for_interval'?: number;
}
export interface ProjectsProjectIdUsersGet200Response {
    'data'?: ProjectUserList;
}
export interface ProjectsProjectIdUsersUserIdPutRequest {
    'is_admin'?: boolean;
}
export interface Suggestion {
    'suggestion_id': string;
    'user_id': string;
    'project_id': string;
    'placed_at'?: string;
    'last_edit'?: string;
    'likes_amount'?: number;
    'name': string;
    'description': string;
    'status': SuggestionStatusEnum;
}

export const SuggestionStatusEnum = {
    Draft: 'draft',
    Discussion: 'discussion',
    Accepted: 'accepted',
    Rejected: 'rejected'
} as const;

export type SuggestionStatusEnum = typeof SuggestionStatusEnum[keyof typeof SuggestionStatusEnum];

export interface SuggestionsSuggestionIdCommentsPostRequest {
    'text': string;
}
export interface SuggestionsSuggestionIdPutRequest {
    'name'?: string;
    'description'?: string;
    'status'?: SuggestionsSuggestionIdPutRequestStatusEnum;
}

export const SuggestionsSuggestionIdPutRequestStatusEnum = {
    Draft: 'draft',
    Discussion: 'discussion',
    Accepted: 'accepted',
    Rejected: 'rejected'
} as const;

export type SuggestionsSuggestionIdPutRequestStatusEnum = typeof SuggestionsSuggestionIdPutRequestStatusEnum[keyof typeof SuggestionsSuggestionIdPutRequestStatusEnum];


/**
 * AuthorizeApi - axios parameter creator
 */
export const AuthorizeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Google перенаправляет сюда пользователя после авторизации. Сервер получает code, обменивает его на access_token, запрашивает профиль пользователя (email, name) и сохраняет сессию. Затем редиректит обратно на /projects. 
         * @summary Callback после авторизации
         * @param {string} code Код авторизации, выданный Google.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCallbackGet: async (code: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('authCallbackGet', 'code', code)
            const localVarPath = `/auth/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Перенаправляет пользователя на страницу авторизации Google OAuth2.
         * @summary Начало авторизации через Google
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Текущий пользователь
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthorizeApi - functional programming interface
 */
export const AuthorizeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthorizeApiAxiosParamCreator(configuration)
    return {
        /**
         * Google перенаправляет сюда пользователя после авторизации. Сервер получает code, обменивает его на access_token, запрашивает профиль пользователя (email, name) и сохраняет сессию. Затем редиректит обратно на /projects. 
         * @summary Callback после авторизации
         * @param {string} code Код авторизации, выданный Google.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authCallbackGet(code: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authCallbackGet(code, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthorizeApi.authCallbackGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Перенаправляет пользователя на страницу авторизации Google OAuth2.
         * @summary Начало авторизации через Google
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthorizeApi.authGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Текущий пользователь
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authMeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrentUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authMeGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthorizeApi.authMeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthorizeApi - factory interface
 */
export const AuthorizeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthorizeApiFp(configuration)
    return {
        /**
         * Google перенаправляет сюда пользователя после авторизации. Сервер получает code, обменивает его на access_token, запрашивает профиль пользователя (email, name) и сохраняет сессию. Затем редиректит обратно на /projects. 
         * @summary Callback после авторизации
         * @param {string} code Код авторизации, выданный Google.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCallbackGet(code: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authCallbackGet(code, options).then((request) => request(axios, basePath));
        },
        /**
         * Перенаправляет пользователя на страницу авторизации Google OAuth2.
         * @summary Начало авторизации через Google
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authGet(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Текущий пользователь
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMeGet(options?: RawAxiosRequestConfig): AxiosPromise<CurrentUser> {
            return localVarFp.authMeGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthorizeApi - object-oriented interface
 */
export class AuthorizeApi extends BaseAPI {
    /**
     * Google перенаправляет сюда пользователя после авторизации. Сервер получает code, обменивает его на access_token, запрашивает профиль пользователя (email, name) и сохраняет сессию. Затем редиректит обратно на /projects. 
     * @summary Callback после авторизации
     * @param {string} code Код авторизации, выданный Google.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authCallbackGet(code: string, options?: RawAxiosRequestConfig) {
        return AuthorizeApiFp(this.configuration).authCallbackGet(code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Перенаправляет пользователя на страницу авторизации Google OAuth2.
     * @summary Начало авторизации через Google
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authGet(options?: RawAxiosRequestConfig) {
        return AuthorizeApiFp(this.configuration).authGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Текущий пользователь
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authMeGet(options?: RawAxiosRequestConfig) {
        return AuthorizeApiFp(this.configuration).authMeGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CommentsApi - axios parameter creator
 */
export const CommentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Ответить на комментарий
         * @param {string} commentId 
         * @param {CommentIdReplyPostRequest} commentIdReplyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentIdReplyPost: async (commentId: string, commentIdReplyPostRequest: CommentIdReplyPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('commentIdReplyPost', 'commentId', commentId)
            // verify required parameter 'commentIdReplyPostRequest' is not null or undefined
            assertParamExists('commentIdReplyPost', 'commentIdReplyPostRequest', commentIdReplyPostRequest)
            const localVarPath = `/{comment_id}/reply`
                .replace(`{${"comment_id"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commentIdReplyPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Удалить комментарий
         * @param {string} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsCommentIdDelete: async (commentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('commentsCommentIdDelete', 'commentId', commentId)
            const localVarPath = `/comments/{comment_id}`
                .replace(`{${"comment_id"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Получить список комментариев к предложению
         * @param {string} suggestionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suggestionsSuggestionIdCommentsGet: async (suggestionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'suggestionId' is not null or undefined
            assertParamExists('suggestionsSuggestionIdCommentsGet', 'suggestionId', suggestionId)
            const localVarPath = `/suggestions/{suggestion_id}/comments`
                .replace(`{${"suggestion_id"}}`, encodeURIComponent(String(suggestionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Оставить комментарий к предложению
         * @param {string} suggestionId 
         * @param {SuggestionsSuggestionIdCommentsPostRequest} suggestionsSuggestionIdCommentsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suggestionsSuggestionIdCommentsPost: async (suggestionId: string, suggestionsSuggestionIdCommentsPostRequest: SuggestionsSuggestionIdCommentsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'suggestionId' is not null or undefined
            assertParamExists('suggestionsSuggestionIdCommentsPost', 'suggestionId', suggestionId)
            // verify required parameter 'suggestionsSuggestionIdCommentsPostRequest' is not null or undefined
            assertParamExists('suggestionsSuggestionIdCommentsPost', 'suggestionsSuggestionIdCommentsPostRequest', suggestionsSuggestionIdCommentsPostRequest)
            const localVarPath = `/suggestions/{suggestion_id}/comments`
                .replace(`{${"suggestion_id"}}`, encodeURIComponent(String(suggestionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(suggestionsSuggestionIdCommentsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommentsApi - functional programming interface
 */
export const CommentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Ответить на комментарий
         * @param {string} commentId 
         * @param {CommentIdReplyPostRequest} commentIdReplyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commentIdReplyPost(commentId: string, commentIdReplyPostRequest: CommentIdReplyPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commentIdReplyPost(commentId, commentIdReplyPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommentsApi.commentIdReplyPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Удалить комментарий
         * @param {string} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commentsCommentIdDelete(commentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commentsCommentIdDelete(commentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommentsApi.commentsCommentIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Получить список комментариев к предложению
         * @param {string} suggestionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async suggestionsSuggestionIdCommentsGet(suggestionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Comment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.suggestionsSuggestionIdCommentsGet(suggestionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommentsApi.suggestionsSuggestionIdCommentsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Оставить комментарий к предложению
         * @param {string} suggestionId 
         * @param {SuggestionsSuggestionIdCommentsPostRequest} suggestionsSuggestionIdCommentsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async suggestionsSuggestionIdCommentsPost(suggestionId: string, suggestionsSuggestionIdCommentsPostRequest: SuggestionsSuggestionIdCommentsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.suggestionsSuggestionIdCommentsPost(suggestionId, suggestionsSuggestionIdCommentsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommentsApi.suggestionsSuggestionIdCommentsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CommentsApi - factory interface
 */
export const CommentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Ответить на комментарий
         * @param {string} commentId 
         * @param {CommentIdReplyPostRequest} commentIdReplyPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentIdReplyPost(commentId: string, commentIdReplyPostRequest: CommentIdReplyPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Comment> {
            return localVarFp.commentIdReplyPost(commentId, commentIdReplyPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Удалить комментарий
         * @param {string} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsCommentIdDelete(commentId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.commentsCommentIdDelete(commentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Получить список комментариев к предложению
         * @param {string} suggestionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suggestionsSuggestionIdCommentsGet(suggestionId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Comment>> {
            return localVarFp.suggestionsSuggestionIdCommentsGet(suggestionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Оставить комментарий к предложению
         * @param {string} suggestionId 
         * @param {SuggestionsSuggestionIdCommentsPostRequest} suggestionsSuggestionIdCommentsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suggestionsSuggestionIdCommentsPost(suggestionId: string, suggestionsSuggestionIdCommentsPostRequest: SuggestionsSuggestionIdCommentsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Comment> {
            return localVarFp.suggestionsSuggestionIdCommentsPost(suggestionId, suggestionsSuggestionIdCommentsPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommentsApi - object-oriented interface
 */
export class CommentsApi extends BaseAPI {
    /**
     * 
     * @summary Ответить на комментарий
     * @param {string} commentId 
     * @param {CommentIdReplyPostRequest} commentIdReplyPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public commentIdReplyPost(commentId: string, commentIdReplyPostRequest: CommentIdReplyPostRequest, options?: RawAxiosRequestConfig) {
        return CommentsApiFp(this.configuration).commentIdReplyPost(commentId, commentIdReplyPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Удалить комментарий
     * @param {string} commentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public commentsCommentIdDelete(commentId: string, options?: RawAxiosRequestConfig) {
        return CommentsApiFp(this.configuration).commentsCommentIdDelete(commentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Получить список комментариев к предложению
     * @param {string} suggestionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public suggestionsSuggestionIdCommentsGet(suggestionId: string, options?: RawAxiosRequestConfig) {
        return CommentsApiFp(this.configuration).suggestionsSuggestionIdCommentsGet(suggestionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Оставить комментарий к предложению
     * @param {string} suggestionId 
     * @param {SuggestionsSuggestionIdCommentsPostRequest} suggestionsSuggestionIdCommentsPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public suggestionsSuggestionIdCommentsPost(suggestionId: string, suggestionsSuggestionIdCommentsPostRequest: SuggestionsSuggestionIdCommentsPostRequest, options?: RawAxiosRequestConfig) {
        return CommentsApiFp(this.configuration).suggestionsSuggestionIdCommentsPost(suggestionId, suggestionsSuggestionIdCommentsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InvitesApi - axios parameter creator
 */
export const InvitesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Получить список приглашений пользователя (себя)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invitesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/invites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Принять или отклонить приглашение
         * @param {string} inviteId 
         * @param {boolean} accept Прниять или отклонить запрос
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invitesInviteIdDelete: async (inviteId: string, accept: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inviteId' is not null or undefined
            assertParamExists('invitesInviteIdDelete', 'inviteId', inviteId)
            // verify required parameter 'accept' is not null or undefined
            assertParamExists('invitesInviteIdDelete', 'accept', accept)
            const localVarPath = `/invites/{invite_id}`
                .replace(`{${"invite_id"}}`, encodeURIComponent(String(inviteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Получить все приглашения в этом проекте
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdInvitesGet: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsProjectIdInvitesGet', 'projectId', projectId)
            const localVarPath = `/projects/{project_id}/invites`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Пригласить пользователя в проект
         * @param {string} projectId 
         * @param {string} userEmail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdInvitesPost: async (projectId: string, userEmail: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsProjectIdInvitesPost', 'projectId', projectId)
            // verify required parameter 'userEmail' is not null or undefined
            assertParamExists('projectsProjectIdInvitesPost', 'userEmail', userEmail)
            const localVarPath = `/projects/{project_id}/invites`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userEmail !== undefined) {
                localVarQueryParameter['user_email'] = userEmail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvitesApi - functional programming interface
 */
export const InvitesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvitesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Получить список приглашений пользователя (себя)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invitesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectsProjectIdInvitesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invitesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvitesApi.invitesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Принять или отклонить приглашение
         * @param {string} inviteId 
         * @param {boolean} accept Прниять или отклонить запрос
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invitesInviteIdDelete(inviteId: string, accept: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invitesInviteIdDelete(inviteId, accept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvitesApi.invitesInviteIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Получить все приглашения в этом проекте
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsProjectIdInvitesGet(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectsProjectIdInvitesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsProjectIdInvitesGet(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvitesApi.projectsProjectIdInvitesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Пригласить пользователя в проект
         * @param {string} projectId 
         * @param {string} userEmail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsProjectIdInvitesPost(projectId: string, userEmail: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsProjectIdInvitesPost(projectId, userEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvitesApi.projectsProjectIdInvitesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InvitesApi - factory interface
 */
export const InvitesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvitesApiFp(configuration)
    return {
        /**
         * 
         * @summary Получить список приглашений пользователя (себя)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invitesGet(options?: RawAxiosRequestConfig): AxiosPromise<ProjectsProjectIdInvitesGet200Response> {
            return localVarFp.invitesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Принять или отклонить приглашение
         * @param {string} inviteId 
         * @param {boolean} accept Прниять или отклонить запрос
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invitesInviteIdDelete(inviteId: string, accept: boolean, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.invitesInviteIdDelete(inviteId, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Получить все приглашения в этом проекте
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdInvitesGet(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectsProjectIdInvitesGet200Response> {
            return localVarFp.projectsProjectIdInvitesGet(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Пригласить пользователя в проект
         * @param {string} projectId 
         * @param {string} userEmail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdInvitesPost(projectId: string, userEmail: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.projectsProjectIdInvitesPost(projectId, userEmail, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvitesApi - object-oriented interface
 */
export class InvitesApi extends BaseAPI {
    /**
     * 
     * @summary Получить список приглашений пользователя (себя)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public invitesGet(options?: RawAxiosRequestConfig) {
        return InvitesApiFp(this.configuration).invitesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Принять или отклонить приглашение
     * @param {string} inviteId 
     * @param {boolean} accept Прниять или отклонить запрос
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public invitesInviteIdDelete(inviteId: string, accept: boolean, options?: RawAxiosRequestConfig) {
        return InvitesApiFp(this.configuration).invitesInviteIdDelete(inviteId, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Получить все приглашения в этом проекте
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsProjectIdInvitesGet(projectId: string, options?: RawAxiosRequestConfig) {
        return InvitesApiFp(this.configuration).projectsProjectIdInvitesGet(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Пригласить пользователя в проект
     * @param {string} projectId 
     * @param {string} userEmail 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsProjectIdInvitesPost(projectId: string, userEmail: string, options?: RawAxiosRequestConfig) {
        return InvitesApiFp(this.configuration).projectsProjectIdInvitesPost(projectId, userEmail, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectsApi - axios parameter creator
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Получить список своих проектов
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creating a project
         * @param {ProjectsPostRequest} projectsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsPost: async (projectsPostRequest: ProjectsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectsPostRequest' is not null or undefined
            assertParamExists('projectsPost', 'projectsPostRequest', projectsPostRequest)
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Получить права связанные с проектом и сопутствующие данные
         * @param {string} projectId Project identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdPermissionsMeGet: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsProjectIdPermissionsMeGet', 'projectId', projectId)
            const localVarPath = `/projects/{projectId}/permissions/me`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Получить настройки проекта
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdSettingsGet: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsProjectIdSettingsGet', 'projectId', projectId)
            const localVarPath = `/projects/{project_id}/settings`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Обновить настройки проекта
         * @param {string} projectId 
         * @param {ProjectsProjectIdSettingsPutRequest} projectsProjectIdSettingsPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdSettingsPut: async (projectId: string, projectsProjectIdSettingsPutRequest: ProjectsProjectIdSettingsPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsProjectIdSettingsPut', 'projectId', projectId)
            // verify required parameter 'projectsProjectIdSettingsPutRequest' is not null or undefined
            assertParamExists('projectsProjectIdSettingsPut', 'projectsProjectIdSettingsPutRequest', projectsProjectIdSettingsPutRequest)
            const localVarPath = `/projects/{project_id}/settings`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectsProjectIdSettingsPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Получить список пользователей проекта
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdUsersGet: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsProjectIdUsersGet', 'projectId', projectId)
            const localVarPath = `/projects/{project_id}/users`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Удалить пользователя из проекта
         * @param {string} projectId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdUsersUserIdDelete: async (projectId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsProjectIdUsersUserIdDelete', 'projectId', projectId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('projectsProjectIdUsersUserIdDelete', 'userId', userId)
            const localVarPath = `/projects/{project_id}/users/{user_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Изменить права пользователя в проекте
         * @param {string} projectId 
         * @param {string} userId 
         * @param {ProjectsProjectIdUsersUserIdPutRequest} projectsProjectIdUsersUserIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdUsersUserIdPut: async (projectId: string, userId: string, projectsProjectIdUsersUserIdPutRequest: ProjectsProjectIdUsersUserIdPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsProjectIdUsersUserIdPut', 'projectId', projectId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('projectsProjectIdUsersUserIdPut', 'userId', userId)
            // verify required parameter 'projectsProjectIdUsersUserIdPutRequest' is not null or undefined
            assertParamExists('projectsProjectIdUsersUserIdPut', 'projectsProjectIdUsersUserIdPutRequest', projectsProjectIdUsersUserIdPutRequest)
            const localVarPath = `/projects/{project_id}/users/{user_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectsProjectIdUsersUserIdPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Получить список своих проектов
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creating a project
         * @param {ProjectsPostRequest} projectsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsPost(projectsPostRequest: ProjectsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectsPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsPost(projectsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Получить права связанные с проектом и сопутствующие данные
         * @param {string} projectId Project identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsProjectIdPermissionsMeGet(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectPermissions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsProjectIdPermissionsMeGet(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsProjectIdPermissionsMeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Получить настройки проекта
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsProjectIdSettingsGet(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectsProjectIdSettingsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsProjectIdSettingsGet(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsProjectIdSettingsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Обновить настройки проекта
         * @param {string} projectId 
         * @param {ProjectsProjectIdSettingsPutRequest} projectsProjectIdSettingsPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsProjectIdSettingsPut(projectId: string, projectsProjectIdSettingsPutRequest: ProjectsProjectIdSettingsPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsProjectIdSettingsPut(projectId, projectsProjectIdSettingsPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsProjectIdSettingsPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Получить список пользователей проекта
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsProjectIdUsersGet(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectsProjectIdUsersGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsProjectIdUsersGet(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsProjectIdUsersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Удалить пользователя из проекта
         * @param {string} projectId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsProjectIdUsersUserIdDelete(projectId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsProjectIdUsersUserIdDelete(projectId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsProjectIdUsersUserIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Изменить права пользователя в проекте
         * @param {string} projectId 
         * @param {string} userId 
         * @param {ProjectsProjectIdUsersUserIdPutRequest} projectsProjectIdUsersUserIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsProjectIdUsersUserIdPut(projectId: string, userId: string, projectsProjectIdUsersUserIdPutRequest: ProjectsProjectIdUsersUserIdPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsProjectIdUsersUserIdPut(projectId, userId, projectsProjectIdUsersUserIdPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsProjectIdUsersUserIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectsApi - factory interface
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * 
         * @summary Получить список своих проектов
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsGet(options?: RawAxiosRequestConfig): AxiosPromise<ProjectsGet200Response> {
            return localVarFp.projectsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creating a project
         * @param {ProjectsPostRequest} projectsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsPost(projectsPostRequest: ProjectsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectsPost201Response> {
            return localVarFp.projectsPost(projectsPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Получить права связанные с проектом и сопутствующие данные
         * @param {string} projectId Project identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdPermissionsMeGet(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectPermissions> {
            return localVarFp.projectsProjectIdPermissionsMeGet(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Получить настройки проекта
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdSettingsGet(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectsProjectIdSettingsGet200Response> {
            return localVarFp.projectsProjectIdSettingsGet(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Обновить настройки проекта
         * @param {string} projectId 
         * @param {ProjectsProjectIdSettingsPutRequest} projectsProjectIdSettingsPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdSettingsPut(projectId: string, projectsProjectIdSettingsPutRequest: ProjectsProjectIdSettingsPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.projectsProjectIdSettingsPut(projectId, projectsProjectIdSettingsPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Получить список пользователей проекта
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdUsersGet(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectsProjectIdUsersGet200Response> {
            return localVarFp.projectsProjectIdUsersGet(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Удалить пользователя из проекта
         * @param {string} projectId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdUsersUserIdDelete(projectId: string, userId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.projectsProjectIdUsersUserIdDelete(projectId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Изменить права пользователя в проекте
         * @param {string} projectId 
         * @param {string} userId 
         * @param {ProjectsProjectIdUsersUserIdPutRequest} projectsProjectIdUsersUserIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdUsersUserIdPut(projectId: string, userId: string, projectsProjectIdUsersUserIdPutRequest: ProjectsProjectIdUsersUserIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.projectsProjectIdUsersUserIdPut(projectId, userId, projectsProjectIdUsersUserIdPutRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 */
export class ProjectsApi extends BaseAPI {
    /**
     * 
     * @summary Получить список своих проектов
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsGet(options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creating a project
     * @param {ProjectsPostRequest} projectsPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsPost(projectsPostRequest: ProjectsPostRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsPost(projectsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Получить права связанные с проектом и сопутствующие данные
     * @param {string} projectId Project identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsProjectIdPermissionsMeGet(projectId: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsProjectIdPermissionsMeGet(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Получить настройки проекта
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsProjectIdSettingsGet(projectId: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsProjectIdSettingsGet(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Обновить настройки проекта
     * @param {string} projectId 
     * @param {ProjectsProjectIdSettingsPutRequest} projectsProjectIdSettingsPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsProjectIdSettingsPut(projectId: string, projectsProjectIdSettingsPutRequest: ProjectsProjectIdSettingsPutRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsProjectIdSettingsPut(projectId, projectsProjectIdSettingsPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Получить список пользователей проекта
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsProjectIdUsersGet(projectId: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsProjectIdUsersGet(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Удалить пользователя из проекта
     * @param {string} projectId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsProjectIdUsersUserIdDelete(projectId: string, userId: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsProjectIdUsersUserIdDelete(projectId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Изменить права пользователя в проекте
     * @param {string} projectId 
     * @param {string} userId 
     * @param {ProjectsProjectIdUsersUserIdPutRequest} projectsProjectIdUsersUserIdPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectsProjectIdUsersUserIdPut(projectId: string, userId: string, projectsProjectIdUsersUserIdPutRequest: ProjectsProjectIdUsersUserIdPutRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsProjectIdUsersUserIdPut(projectId, userId, projectsProjectIdUsersUserIdPutRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SuggestionsApi - axios parameter creator
 */
export const SuggestionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Если указать query параметр status=draft, вернутся только черновики. 
         * @summary Получить список предложений проекта
         * @param {string} projectId 
         * @param {ProjectProjectIdSuggestionsGetStatusEnum} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectProjectIdSuggestionsGet: async (projectId: string, status?: ProjectProjectIdSuggestionsGetStatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectProjectIdSuggestionsGet', 'projectId', projectId)
            const localVarPath = `/project/{project_id}/suggestions`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Если status не указан или равен \"draft\", создаётся черновик. Если status=\"new\" и заполнены все поля, создаётся опубликованное предложение. 
         * @summary Создать предложение или черновик
         * @param {string} projectId 
         * @param {ProjectProjectIdSuggestionsPostRequest} projectProjectIdSuggestionsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectProjectIdSuggestionsPost: async (projectId: string, projectProjectIdSuggestionsPostRequest: ProjectProjectIdSuggestionsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectProjectIdSuggestionsPost', 'projectId', projectId)
            // verify required parameter 'projectProjectIdSuggestionsPostRequest' is not null or undefined
            assertParamExists('projectProjectIdSuggestionsPost', 'projectProjectIdSuggestionsPostRequest', projectProjectIdSuggestionsPostRequest)
            const localVarPath = `/project/{project_id}/suggestions`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectProjectIdSuggestionsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Удаляет предложение или черновик по его id
         * @summary Удалить предложение или черновик
         * @param {string} suggestionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suggestionsSuggestionIdDelete: async (suggestionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'suggestionId' is not null or undefined
            assertParamExists('suggestionsSuggestionIdDelete', 'suggestionId', suggestionId)
            const localVarPath = `/suggestions/{suggestion_id}`
                .replace(`{${"suggestion_id"}}`, encodeURIComponent(String(suggestionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Нужно для того, чтобы можно было зайти на страницу самого предложения для просмотра контента, связанного с ним
         * @summary Получить одно предложение
         * @param {string} suggestionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suggestionsSuggestionIdGet: async (suggestionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'suggestionId' is not null or undefined
            assertParamExists('suggestionsSuggestionIdGet', 'suggestionId', suggestionId)
            const localVarPath = `/suggestions/{suggestion_id}`
                .replace(`{${"suggestion_id"}}`, encodeURIComponent(String(suggestionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Убрать конкретную реакцию
         * @param {string} suggestionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suggestionsSuggestionIdLikesDelete: async (suggestionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'suggestionId' is not null or undefined
            assertParamExists('suggestionsSuggestionIdLikesDelete', 'suggestionId', suggestionId)
            const localVarPath = `/suggestions/{suggestion_id}/likes`
                .replace(`{${"suggestion_id"}}`, encodeURIComponent(String(suggestionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Добавить реакцию
         * @param {string} suggestionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suggestionsSuggestionIdLikesPost: async (suggestionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'suggestionId' is not null or undefined
            assertParamExists('suggestionsSuggestionIdLikesPost', 'suggestionId', suggestionId)
            const localVarPath = `/suggestions/{suggestion_id}/likes`
                .replace(`{${"suggestion_id"}}`, encodeURIComponent(String(suggestionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Частично обновляет поля предложения. Для черновиков можно менять status=draft или name/description. При смене status=draft→new черновик публикуется. 
         * @summary Обновить предложение или черновик
         * @param {string} suggestionId 
         * @param {SuggestionsSuggestionIdPutRequest} suggestionsSuggestionIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suggestionsSuggestionIdPut: async (suggestionId: string, suggestionsSuggestionIdPutRequest: SuggestionsSuggestionIdPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'suggestionId' is not null or undefined
            assertParamExists('suggestionsSuggestionIdPut', 'suggestionId', suggestionId)
            // verify required parameter 'suggestionsSuggestionIdPutRequest' is not null or undefined
            assertParamExists('suggestionsSuggestionIdPut', 'suggestionsSuggestionIdPutRequest', suggestionsSuggestionIdPutRequest)
            const localVarPath = `/suggestions/{suggestion_id}`
                .replace(`{${"suggestion_id"}}`, encodeURIComponent(String(suggestionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(suggestionsSuggestionIdPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SuggestionsApi - functional programming interface
 */
export const SuggestionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SuggestionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Если указать query параметр status=draft, вернутся только черновики. 
         * @summary Получить список предложений проекта
         * @param {string} projectId 
         * @param {ProjectProjectIdSuggestionsGetStatusEnum} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectProjectIdSuggestionsGet(projectId: string, status?: ProjectProjectIdSuggestionsGetStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectProjectIdSuggestionsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectProjectIdSuggestionsGet(projectId, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SuggestionsApi.projectProjectIdSuggestionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Если status не указан или равен \"draft\", создаётся черновик. Если status=\"new\" и заполнены все поля, создаётся опубликованное предложение. 
         * @summary Создать предложение или черновик
         * @param {string} projectId 
         * @param {ProjectProjectIdSuggestionsPostRequest} projectProjectIdSuggestionsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectProjectIdSuggestionsPost(projectId: string, projectProjectIdSuggestionsPostRequest: ProjectProjectIdSuggestionsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Suggestion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectProjectIdSuggestionsPost(projectId, projectProjectIdSuggestionsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SuggestionsApi.projectProjectIdSuggestionsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Удаляет предложение или черновик по его id
         * @summary Удалить предложение или черновик
         * @param {string} suggestionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async suggestionsSuggestionIdDelete(suggestionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.suggestionsSuggestionIdDelete(suggestionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SuggestionsApi.suggestionsSuggestionIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Нужно для того, чтобы можно было зайти на страницу самого предложения для просмотра контента, связанного с ним
         * @summary Получить одно предложение
         * @param {string} suggestionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async suggestionsSuggestionIdGet(suggestionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Suggestion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.suggestionsSuggestionIdGet(suggestionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SuggestionsApi.suggestionsSuggestionIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Убрать конкретную реакцию
         * @param {string} suggestionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async suggestionsSuggestionIdLikesDelete(suggestionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.suggestionsSuggestionIdLikesDelete(suggestionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SuggestionsApi.suggestionsSuggestionIdLikesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Добавить реакцию
         * @param {string} suggestionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async suggestionsSuggestionIdLikesPost(suggestionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.suggestionsSuggestionIdLikesPost(suggestionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SuggestionsApi.suggestionsSuggestionIdLikesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Частично обновляет поля предложения. Для черновиков можно менять status=draft или name/description. При смене status=draft→new черновик публикуется. 
         * @summary Обновить предложение или черновик
         * @param {string} suggestionId 
         * @param {SuggestionsSuggestionIdPutRequest} suggestionsSuggestionIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async suggestionsSuggestionIdPut(suggestionId: string, suggestionsSuggestionIdPutRequest: SuggestionsSuggestionIdPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Suggestion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.suggestionsSuggestionIdPut(suggestionId, suggestionsSuggestionIdPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SuggestionsApi.suggestionsSuggestionIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SuggestionsApi - factory interface
 */
export const SuggestionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SuggestionsApiFp(configuration)
    return {
        /**
         * Если указать query параметр status=draft, вернутся только черновики. 
         * @summary Получить список предложений проекта
         * @param {string} projectId 
         * @param {ProjectProjectIdSuggestionsGetStatusEnum} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectProjectIdSuggestionsGet(projectId: string, status?: ProjectProjectIdSuggestionsGetStatusEnum, options?: RawAxiosRequestConfig): AxiosPromise<ProjectProjectIdSuggestionsGet200Response> {
            return localVarFp.projectProjectIdSuggestionsGet(projectId, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Если status не указан или равен \"draft\", создаётся черновик. Если status=\"new\" и заполнены все поля, создаётся опубликованное предложение. 
         * @summary Создать предложение или черновик
         * @param {string} projectId 
         * @param {ProjectProjectIdSuggestionsPostRequest} projectProjectIdSuggestionsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectProjectIdSuggestionsPost(projectId: string, projectProjectIdSuggestionsPostRequest: ProjectProjectIdSuggestionsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Suggestion> {
            return localVarFp.projectProjectIdSuggestionsPost(projectId, projectProjectIdSuggestionsPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Удаляет предложение или черновик по его id
         * @summary Удалить предложение или черновик
         * @param {string} suggestionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suggestionsSuggestionIdDelete(suggestionId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.suggestionsSuggestionIdDelete(suggestionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Нужно для того, чтобы можно было зайти на страницу самого предложения для просмотра контента, связанного с ним
         * @summary Получить одно предложение
         * @param {string} suggestionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suggestionsSuggestionIdGet(suggestionId: string, options?: RawAxiosRequestConfig): AxiosPromise<Suggestion> {
            return localVarFp.suggestionsSuggestionIdGet(suggestionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Убрать конкретную реакцию
         * @param {string} suggestionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suggestionsSuggestionIdLikesDelete(suggestionId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.suggestionsSuggestionIdLikesDelete(suggestionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Добавить реакцию
         * @param {string} suggestionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suggestionsSuggestionIdLikesPost(suggestionId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.suggestionsSuggestionIdLikesPost(suggestionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Частично обновляет поля предложения. Для черновиков можно менять status=draft или name/description. При смене status=draft→new черновик публикуется. 
         * @summary Обновить предложение или черновик
         * @param {string} suggestionId 
         * @param {SuggestionsSuggestionIdPutRequest} suggestionsSuggestionIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suggestionsSuggestionIdPut(suggestionId: string, suggestionsSuggestionIdPutRequest: SuggestionsSuggestionIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<Suggestion> {
            return localVarFp.suggestionsSuggestionIdPut(suggestionId, suggestionsSuggestionIdPutRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SuggestionsApi - object-oriented interface
 */
export class SuggestionsApi extends BaseAPI {
    /**
     * Если указать query параметр status=draft, вернутся только черновики. 
     * @summary Получить список предложений проекта
     * @param {string} projectId 
     * @param {ProjectProjectIdSuggestionsGetStatusEnum} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectProjectIdSuggestionsGet(projectId: string, status?: ProjectProjectIdSuggestionsGetStatusEnum, options?: RawAxiosRequestConfig) {
        return SuggestionsApiFp(this.configuration).projectProjectIdSuggestionsGet(projectId, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Если status не указан или равен \"draft\", создаётся черновик. Если status=\"new\" и заполнены все поля, создаётся опубликованное предложение. 
     * @summary Создать предложение или черновик
     * @param {string} projectId 
     * @param {ProjectProjectIdSuggestionsPostRequest} projectProjectIdSuggestionsPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public projectProjectIdSuggestionsPost(projectId: string, projectProjectIdSuggestionsPostRequest: ProjectProjectIdSuggestionsPostRequest, options?: RawAxiosRequestConfig) {
        return SuggestionsApiFp(this.configuration).projectProjectIdSuggestionsPost(projectId, projectProjectIdSuggestionsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Удаляет предложение или черновик по его id
     * @summary Удалить предложение или черновик
     * @param {string} suggestionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public suggestionsSuggestionIdDelete(suggestionId: string, options?: RawAxiosRequestConfig) {
        return SuggestionsApiFp(this.configuration).suggestionsSuggestionIdDelete(suggestionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Нужно для того, чтобы можно было зайти на страницу самого предложения для просмотра контента, связанного с ним
     * @summary Получить одно предложение
     * @param {string} suggestionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public suggestionsSuggestionIdGet(suggestionId: string, options?: RawAxiosRequestConfig) {
        return SuggestionsApiFp(this.configuration).suggestionsSuggestionIdGet(suggestionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Убрать конкретную реакцию
     * @param {string} suggestionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public suggestionsSuggestionIdLikesDelete(suggestionId: string, options?: RawAxiosRequestConfig) {
        return SuggestionsApiFp(this.configuration).suggestionsSuggestionIdLikesDelete(suggestionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Добавить реакцию
     * @param {string} suggestionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public suggestionsSuggestionIdLikesPost(suggestionId: string, options?: RawAxiosRequestConfig) {
        return SuggestionsApiFp(this.configuration).suggestionsSuggestionIdLikesPost(suggestionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Частично обновляет поля предложения. Для черновиков можно менять status=draft или name/description. При смене status=draft→new черновик публикуется. 
     * @summary Обновить предложение или черновик
     * @param {string} suggestionId 
     * @param {SuggestionsSuggestionIdPutRequest} suggestionsSuggestionIdPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public suggestionsSuggestionIdPut(suggestionId: string, suggestionsSuggestionIdPutRequest: SuggestionsSuggestionIdPutRequest, options?: RawAxiosRequestConfig) {
        return SuggestionsApiFp(this.configuration).suggestionsSuggestionIdPut(suggestionId, suggestionsSuggestionIdPutRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

export const ProjectProjectIdSuggestionsGetStatusEnum = {
    Draft: 'draft',
    Discussion: 'discussion',
    Accepted: 'accepted',
    Rejected: 'rejected'
} as const;
export type ProjectProjectIdSuggestionsGetStatusEnum = typeof ProjectProjectIdSuggestionsGetStatusEnum[keyof typeof ProjectProjectIdSuggestionsGetStatusEnum];


